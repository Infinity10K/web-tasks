# Домашнее задание 6

## 1. Дополнительные функции

Целью домашнего задания является исследование и внедрение:
- websocket real-time обновлений (centrifugo),
- фоновых и периодических задач (celery + celerybeat),
- механизма кеширования,
- email-уведомлений,
- полнотекстового поиска.

## 2. Срок сдачи

ДЗ6, ДЗ7 нужно сдать к экзамену. Работы, отправленные на проверку позже, оцениваются в половину максимальных баллов на пересдаче.

До начала экзамена, необходимо:
- пройти ревью у ментора (в формате PR в репозитории) и внести правки;
- передать работу на финальную проверку преподавателям.

## 3. Redis + Celery + Celerybeat

Нужно настроить celery и celerybeat и использовать Redis в качестве брокера сообщений для celery. В следующих частях домашнего задания celery будет использоваться для асинхронного выполнения задач (обычно это долгие или тяжелые задачи, которые не рекомендуется выполнять в основном потоке воркеров gunicorn) - отсылка нотификаций в smtp-сeрвер, пересчет кешей, походы по api в centrifugo. Также рекомендуется сразу указать celery в качестве default cache backend для django.

Для этого нужно установить следующие зависимости в requirements.txt: celery, redis (python-клиент), django-redis, redbeat (для хранения расписания тасок в redis).

Для использования redis в качестве cache backend в settings.py нужно указать:
```
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": f"redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_CACHE_DB}",
        "OPTIONS": {"CLIENT_CLASS": "django_redis.client.DefaultClient"},
        "TIMEOUT": 60 * 10,
    }
}
```

Для использования redis в качестве брокера сообщений в settings.py нужно указать:
```
CELERY_BROKER_URL = f"redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_BROKER_DB}"
CELERY_RESULT_BACKEND = f"redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_BEAT_DB}"
```

Для использования redis в качестве места хранения расписания тасок в settings.py нужно указать:
```
CELERY_BEAT_SCHEDULER = "redbeat.RedBeatScheduler"
CELERY_REDBEAT_REDIS_URL = f"redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_BEAT_DB}"
```

Должны быть использованы разные redis db (разные номера баз) для кэша, брокера сообщений, расписаний celerybeat. Все настройки подключения должны быть вынесены в конфиге проекта. Также в docker-compose.yml должен появиться новый сервис для redis.

## 4. Кеширование и фоновый запуск

Необходимо подготовить и вывести данные для правой колонки (лучшие пользователи, популярные теги). Популярные теги - это 10 тегов с самым большим количеством вопросов за последние 3 месяца. Лучшие пользователи - это 10 пользователей задавших самые популярные вопросы или давших самые популярные ответы за последнюю неделю.

Так как запросы на предполагаются тяжелыми, необходимо кэшировать данные. Вьюшки не должны всегда запускать эти запросы, а по возможности брать данные из кэша. Необходимо реализовать две celery-таски, пересчитывающие и обновляющие данные кеши, а также сделать таски периодическими с помощью celerybeat. Если кеша в данный момент нет в redis, вьюха должна забрать актуальные данные из БД и обновить кеш.

В docker-compose.yml должны появиться новыe сервисы для celery (worker) и celerybeat (beat).

## 5. Real-time сообщения
Необходимо реализовать рассылку мгновенных сообщений о новых ответах всем пользователям, находящимся на странице определенного вопроса. Допустим есть два пользователя A и B. Оба находятся на странице одного вопроса, например **/question/33**. Пользователь A добавляет ответ на этот вопрос, пользователь B должен увидеть ответ без перезагрузки страницы.

Для этого необходимо настроить сервер [Сentrifugo](https://centrifugal.dev/docs/getting-started/quickstart). Достаточно создать один namespace и разрешить коннектиться к нему клиентов centrifugo (с connection-токеном, без subscription-токена).

На бекендной стороне добавить код, отправляющий сообщения в Сentrifugo, например, с помощью библиотеки pycent или requests. Отправка сообщений в Centrifugo должна выполняться в отдельной celery-таске (не напрямую из view).

На странице вопроса добавить JavaScript опрашивающий Сentrifugo сервер. В состав Сentrifugo входят [JavaScript-библиотеки](https://centrifugal.dev/docs/transports/websocket), их необходимо использовать для создания корректного соединения с сервером Сentrifugo по протоколу websocket. На клиентской стороне необходимо проработать корректное обновление страницы вопроса:
- если ответов не было и появился первый - список должен отобразиться корректно;
- если пользователь находится на первой странице ответов - новый ответ должен добавляться в список без перезагрузки;
- если пользователь находится не на первой странице - показывается alert о новом ответе (без попытки “вставить” ответ в текущий список).

Настройки подключения к centrifugo (секретные ключи, etc) должны лежать в конфиге проекта. Также в docker-compose.yml должен появиться новый сервис для centrifugo.

## 6. Нотификация на email

Нужно настроить отправку email-уведомлений автору вопроса при появлении нового ответа.

Для этого необходимо настроить отправку email в settings.py:
```
EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST = ...
EMAIL_PORT = ...
EMAIL_USE_TLS = False
DEFAULT_FROM_EMAIL = ...
```

Сами письма должны посылаться в выполняться в отдельной celery-таске. В коде можно использовать утилиты, предлагаемые django:
```
from django.core.mail import send_mail
```

Настройки подключения к smtp-серверу должны лежать в конфиге проекта. Также в docker-compose.yml должен появиться новый сервис для smtp (в качестве smtp-сервера для локальной разработки можно использовать maildev).

## 7. Полнотекстовый поиск
Необходимо реализовать поиск по заголовкам и содержимому вопросов. Пользователь вводит текст в поисковой строке, которая находиться в шапке. По введенному тексту СУБД должна находить совпадения, используя полнотекстовые индексы. Результаты поиска отображаются пользователю в виде поисковых подсказок (выпадающий список под поисковой строкой).

Запрос должен отправляться автоматически по мере ввода пользователем частей текста. Необходимо удостовериться, что мы не перегружаем сервер лишними запросами, отправляя запрос на каждый новый введенный символ во время печати.

## 8. Баллы

### Максимальные баллы за ДЗ - 20 баллов

Redis + Celery + Celery Beat — 4 балла
- Redis сконфигурирован как broker celery и как cache backend django — 1
- Используются разные Redis DB для cache/broker/beat schedule — 1
- Все параметры подключения к Redis лежат в конфиге проекта — 1
- Добавлен сервис redis в docker-compose.yml — 1

Кэширование через Celery — 5 балла
- Реализованы 2 celery-таски пересчёта: popular tags и best members — 2
- Задачи запускаются периодически через celerybeat, расписание настраивается из settings.py — 1
- В вьюхах данные берутся из кэша с fallback в БД — 1
- Добавлены сервисы celery и celerybeat в docker-compose.yml — 1

Realtime с помощью Centrifugo — 5 балла
- Настроен и поднят сервер centrifugo, настройки подключения и секретные токены лежат в конфиге проекта — 2
- На бекенде есть отправка сообщений о новом ответе на вопрос в отдельной celery-таске — 1
- На фронтенде корректно обработаны сценарии добавления ответа в вопрос без ответов, добавления ответа на первую страницу, alert на других страницах - 1
- Добавлен сервис centrifugo в docker-compose.yml — 1

Email-уведомления — 3 балла
- Настроена отправка email в settings.py, все параметры подключения лежат в конфиге проекта — 1
- Уведомление автору вопроса о новом ответе отправляется отдельной сelery-таске — 1
- Добавлен сервис maildev в docker-compose.yml — 1

Полнотекстовый поиск — 3 балла
- Корректная работа поиска по заголовку и содержимому (используются полнотекстовый индекс, а не icontains) - 1
- Поисковые подсказки (есть выпадающий список с suggestions) - 1
- Отправка данных на сервер по мере ввода (debounce/throttle) - 1


## 9. Полезные ссылки
- Документация по Centrifugo: [серверная часть](https://centrifugal.dev/docs/server/configuration) и [клиентская часть](https://centrifugal.dev/docs/transports/websocket);
- [Библиотека requests для Python](http://docs.python-requests.org/en/latest/);
- [Inclusion tags в Django](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#inclusion-tags);
- [Настройка кэширования в Django](https://docs.djangoproject.com/en/5.0/topics/cache/#filesystem-caching);
- [Использование кэшей в Django](https://docs.djangoproject.com/en/5.0/topics/cache/#the-low-level-cache-api);
- [Полнотекстовый поиск в MySQL](http://www.mysql.ru/docs/man/Fulltext_Search.html);
- [Cron](https://ru.wikipedia.org/wiki/Cron).
